!	:! filter lines or execute an external command
!!	:!! repeat last `:!` command
#	:# same as `:number`
&	:& repeat last `:substitute`
star	:* execute contents of a register
<	:< shift lines one 'shiftwidth' left
=	:= print the cursor line number
>	:> shift lines one 'shiftwidth' right
@	:@ execute contents of a register
@@	:@@ repeat the previous `:@`
Next	:N[ext] go to previous file in the argument list
Print	:P[rint] print lines
X	:X ask for encryption key
append	:a[ppend] append text
abbreviate	:ab[breviate] enter abbreviation
abclear	:abc[lear] remove all abbreviations
aboveleft	:abo[veleft] make split window appear left or above
all	:al[l] open a window for each file in the argument list
amenu	:am[enu] enter new menu item for all modes
anoremenu	:an[oremenu] enter a new menu for all modes that will not be remapped
args	:ar[gs] print the argument list
argadd	:arga[dd] add items to the argument list
argdelete	:argd[elete] delete items from the argument list
argedit	:arge[dit] add item to the argument list and edit it
argdo	:argdo do a command on all items in the argument list
argglobal	:argg[lobal] define the global argument list
arglocal	:argl[ocal] define a local argument list
argument	:argu[ment] go to specific file in the argument list
ascii	:as[cii] print ascii value of character under the cursor
autocmd	:au[tocmd] enter or show autocommands
augroup	:aug[roup] select the autocommand group to use
aunmenu	:aun[menu] remove menu for all modes
buffer	:b[uffer] go to specific buffer in the buffer list
bNext	:bN[ext] go to previous buffer in the buffer list
ball	:ba[ll] open a window for each buffer in the buffer list
badd	:bad[d] add buffer to the buffer list
bdelete	:bd[elete] remove a buffer from the buffer list
behave	:be[have] set mouse and selection behavior
belowright	:bel[owright] make split window appear right or below
bfirst	:bf[irst] go to first buffer in the buffer list
blast	:bl[ast] go to last buffer in the buffer list
bmodified	:bm[odified] go to next buffer in the buffer list that has been modified
bnext	:bn[ext] go to next buffer in the buffer list
botright	:bo[tright] make split window appear at bottom or far right
bprevious	:bp[revious] go to previous buffer in the buffer list
brewind	:br[ewind] go to first buffer in the buffer list
break	:brea[k] break out of while loop
breakadd	:breaka[dd] add a debugger breakpoint
breakdel	:breakd[el] delete a debugger breakpoint
breaklist	:breakl[ist] list debugger breakpoints
browse	:bro[wse] use file selection dialog
bufdo	:bufdo execute command in each listed buffer
buffers	:buffers list all files in the buffer list
bunload	:bun[load] unload a specific buffer
bwipeout	:bw[ipeout] really delete a buffer
change	:c[hange] replace a line or series of lines
cNext	:cN[ext] go to previous error
cNfile	:cNf[ile] go to last error in previous file
cabbrev	:ca[bbrev] like `:abbreviate` but for Command-line mode
cabclear	:cabc[lear] clear all abbreviations for Command-line mode
caddbuffer	:caddb[uffer] add errors from buffer
caddexpr	:cad[dexpr] add errors from expr
caddfile	:caddf[ile] add error message to current quickfix list
call	:cal[l] call a function
catch	:cat[ch] part of a :try command
cbuffer	:cb[uffer] parse error messages and jump to first error
cc	:cc go to specific error
cclose	:ccl[ose] close quickfix window
cd	:cd change directory
center	:ce[nter] format lines at the center
cexpr	:cex[pr] read errors from expr and jump to first
cfile	:cf[ile] read file with error messages and jump to first
cfirst	:cfir[st] go to the specified error, default first one
cgetbuffer	:cgetb[uffer] get errors from buffer
cgetexpr	:cgete[xpr] get errors from expr
cgetfile	:cg[etfile] read file with error messages
changes	:cha[nges] print the change list
chdir	:chd[ir] change directory
checkpath	:che[ckpath] list included files
checktime	:checkt[ime] check timestamp of loaded buffers
clist	:cl[ist] list all errors
clast	:cla[st] go to the specified error, default last one
close	:clo[se] close current window
cmap	:cm[ap] like `:map` but for Command-line mode
cmapclear	:cmapc[lear] clear all mappings for Command-line mode
cmenu	:cme[nu] add menu for Command-line mode
cnext	:cn[ext] go to next error
cnewer	:cnew[er] go to newer error list
cnfile	:cnf[ile] go to first error in next file
cnoremap	:cno[remap] like `:noremap` but for Command-line mode
cnoreabbrev	:cnorea[bbrev] like `:noreabbrev` but for Command-line mode
cnoremenu	:cnoreme[nu] like `:noremenu` but for Command-line mode
copy	:co[py] copy lines
colder	:col[der] go to older error list
colorscheme	:colo[rscheme] load a specific color scheme
command	:com[mand] create user-defined command
comclear	:comc[lear] clear all user-defined commands
compiler	:comp[iler] do settings for a specific compiler
continue	:con[tinue] go back to :while
confirm	:conf[irm] prompt user when confirmation required
copen	:cope[n] open quickfix window
cprevious	:cp[revious] go to previous error
cpfile	:cpf[ile] go to last error in previous file
cquit	:cq[uit] quit Vim with an error code
crewind	:cr[ewind] go to the specified error, default first one
cscope	:cs[cope] execute cscope command
cstag	:cst[ag] use cscope to jump to a tag
cunmap	:cu[nmap] like `:unmap` but for Command-line mode
cunabbrev	:cuna[bbrev] like `:unabbrev` but for Command-line mode
cunmenu	:cunme[nu] remove menu for Command-line mode
cwindow	:cw[indow] open or close quickfix window
delete	:d[elete] delete lines
delmarks	:delm[arks] delete marks
debug	:deb[ug] run a command in debugging mode
debuggreedy	:debugg[reedy] read debug mode commands from normal input
delcommand	:delc[ommand] delete user-defined command
delfunction	:delf[unction] delete a user function
diffupdate	:dif[fupdate] update 'diff' buffers
diffget	:diffg[et] remove differences in current buffer
diffoff	:diffo[ff] switch off diff mode
diffpatch	:diffp[atch] apply a patch and show differences
diffput	:diffpu[t] remove differences in other buffer
diffsplit	:diffs[plit] show differences with another file
diffthis	:diffthis make current window a diff window
digraphs	:dig[raphs] show or enter digraphs
display	:di[splay] display registers
djump	:dj[ump] jump to #define
dlist	:dl[ist] list #defines
doautocmd	:do[autocmd] apply autocommands to current buffer
doautoall	:doautoa[ll] apply autocommands for all loaded buffers
drop	:dr[op] jump to window editing file or edit file in current window
dsearch	:ds[earch] list one #define
dsplit	:dsp[lit] split window and jump to #define
edit	:e[dit] edit a file
earlier	:ea[rlier] go to older change, undo
echo	:ec[ho] echoes the result of expressions
echoerr	:echoe[rr] like :echo, show like an error and use history
echohl	:echoh[l] set highlighting for echo commands
echomsg	:echom[sg] same as :echo, put message in history
echon	:echon same as :echo, but without <EOL>
else	:el[se] part of an :if command
elseif	:elsei[f] part of an :if command
emenu	:em[enu] execute a menu by name
endif	:en[dif] end previous :if
endfor	:endfo[r] end previous :for
endfunction	:endf[unction] end of a user function
endtry	:endt[ry] end previous :try
endwhile	:endw[hile] end previous :while
enew	:ene[w] edit a new, unnamed buffer
ex	:ex same as `:edit`
execute	:exe[cute] execute result of expressions
exit	:exi[t] same as `:xit`
exusage	:exu[sage] overview of Ex commands
file	:f[ile] show or set the current file name
files	:files list all files in the buffer list
filetype	:filet[ype] switch file type detection on/off
find	:fin[d] find file in 'path' and edit it
finally	:fina[lly] part of a :try command
finish	:fini[sh] quit sourcing a Vim script
first	:fir[st] go to the first file in the argument list
fixdel	:fix[del] set key code of <Del>
fold	:fo[ld] create a fold
foldclose	:foldc[lose] close folds
folddoopen	:foldd[oopen] execute command on lines not in a closed fold
folddoclosed	:folddoc[losed] execute command on lines in a closed fold
foldopen	:foldo[pen] open folds
for	:for for loop
function	:fu[nction] define a user function
global	:g[lobal] execute commands for matching lines
goto	:go[to] go to byte in the buffer
grep	:gr[ep] run 'grepprg' and jump to first match
grepadd	:grepa[dd] like :grep, but append to current list
gui	:gu[i] start the GUI
gvim	:gv[im] start the GUI
hardcopy	:ha[rdcopy] send text to the printer
help	:h[elp] open a help window
helpfind	:helpf[ind] dialog to open a help window
helpgrep	:helpg[rep] like `:grep` but searches help files
helptags	:helpt[ags] generate help tags for a directory
highlight	:hi[ghlight] specify highlighting methods
hide	:hid[e] hide current buffer for a command
history	:his[tory] print a history list
insert	:i[nsert] insert text
iabbrev	:ia[bbrev] like `:abbrev` but for Insert mode
iabclear	:iabc[lear] like `:abclear` but for Insert mode
if	:if execute commands when condition met
ijump	:ij[ump] jump to definition of identifier
ilist	:il[ist] list lines where identifier matches
imap	:im[ap] like `:map` but for Insert mode
imapclear	:imapc[lear] like `:mapclear` but for Insert mode
imenu	:ime[nu] add menu for Insert mode
inoremap	:ino[remap] like `:noremap` but for Insert mode
inoreabbrev	:inorea[bbrev] like `:noreabbrev` but for Insert mode
inoremenu	:inoreme[nu] like `:noremenu` but for Insert mode
intro	:int[ro] print the introductory message
isearch	:is[earch] list one line where identifier matches
isplit	:isp[lit] split window and jump to definition of identifier
iunmap	:iu[nmap] like `:unmap` but for Insert mode
iunabbrev	:iuna[bbrev] like `:unabbrev` but for Insert mode
iunmenu	:iunme[nu] remove menu for Insert mode
join	:j[oin] join lines
jumps	:ju[mps] print the jump list
k	:k set a mark
keepalt	:keepa[lt] following command keeps the alternate file
keepmarks	:kee[pmarks] following command keeps marks where they are
keepjumps	:keepj[umps] following command keeps jumplist and marks
lNext	:lN[ext] go to previous entry in location list
lNfile	:lNf[ile] go to last entry in previous file
list	:l[ist] print lines
laddexpr	:lad[dexpr] add locations from expr
laddbuffer	:laddb[uffer] add locations from buffer
laddfile	:laddf[ile] add locations to current location list
last	:la[st] go to the last file in the argument list
language	:lan[guage] set the language (locale)
later	:lat[er] go to newer change, redo
lbuffer	:lb[uffer] parse locations and jump to first location
lcd	:lc[d] change directory locally
lchdir	:lch[dir] change directory locally
lclose	:lcl[ose] close location window
lcscope	:lcs[cope] like `:cscope` but uses location list
left	:le[ft] left align lines
leftabove	:lefta[bove] make split window appear left or above
let	:let assign a value to a variable or option
lexpr	:lex[pr] read locations from expr and jump to first
lfile	:lf[ile] read file with locations and jump to first
lfirst	:lfir[st] go to the specified location, default first one
lgetbuffer	:lgetb[uffer] get locations from buffer
lgetexpr	:lgete[xpr] get locations from expr
lgetfile	:lg[etfile] read file with locations
lgrep	:lgr[ep] run 'grepprg' and jump to first match
lgrepadd	:lgrepa[dd] like :grep, but append to current list
lhelpgrep	:lh[elpgrep] like `:helpgrep` but uses location list
ll	:ll go to specific location
llast	:lla[st] go to the specified location, default last one
llist	:lli[st] list all locations
lmake	:lmak[e] execute external command 'makeprg' and parse error messages
lmap	:lm[ap] like `:map!` but includes Lang-Arg mode
lmapclear	:lmapc[lear] like `:mapclear!` but includes Lang-Arg mode
lnext	:lne[xt] go to next location
lnewer	:lnew[er] go to newer location list
lnfile	:lnf[ile] go to first location in next file
lnoremap	:ln[oremap] like `:noremap!` but includes Lang-Arg mode
loadkeymap	:loadk[eymap] load the following keymaps until EOF
loadview	:lo[adview] load view for current window from a file
lockmarks	:loc[kmarks] following command keeps marks where they are
lockvar	:lockv[ar] lock variables
lolder	:lol[der] go to older location list
lopen	:lope[n] open location window
lprevious	:lp[revious] go to previous location
lpfile	:lpf[ile] go to last location in previous file
lrewind	:lr[ewind] go to the specified location, default first one
ls	:ls list all buffers
ltag	:lt[ag] jump to tag and add matching tags to the location list
lunmap	:lu[nmap] like `:unmap!` but includes Lang-Arg mode
lua	:lua execute Lua command
luado	:luad[o] execute Lua command for each line
luafile	:luaf[ile] execute Lua script file
lvimgrep	:lv[imgrep] search for pattern in files
lvimgrepadd	:lvimgrepa[dd] like :vimgrep, but append to current list
lwindow	:lw[indow] open or close location window
move	:m[ove] move lines
mark	:ma[rk] set a mark
make	:mak[e] execute external command 'makeprg' and parse error messages
map	:map show or enter a mapping
mapclear	:mapc[lear] clear all mappings for Normal and Visual mode
marks	:marks list all marks
match	:mat[ch] define a match to highlight
menu	:me[nu] enter a new menu item
menutranslate	:menut[ranslate] add a menu translation item
messages	:mes[sages] view previously displayed messages
mkexrc	:mk[exrc] write current mappings and settings to a file
mksession	:mks[ession] write session info to a file
mkspell	:mksp[ell] produce .spl spell file
mkvimrc	:mkv[imrc] write current mappings and settings to a file
mkview	:mkvie[w] write view of current window to a file
mode	:mod[e] show or change the screen mode
mzscheme	:mz[scheme] execute MzScheme command
mzfile	:mzf[ile] execute MzScheme script file
nbclose	:nbc[lose] close the current Netbeans session
nbkey	:nb[key] pass a key to Netbeans
nbstart	:nbs[art] start a new Netbeans session
next	:n[ext] go to next file in the argument list
new	:new create a new empty window
nmap	:nm[ap] like `:map` but for Normal mode
nmapclear	:nmapc[lear] clear all mappings for Normal mode
nmenu	:nme[nu] add menu for Normal mode
nnoremap	:nn[oremap] like `:noremap` but for Normal mode
nnoremenu	:nnoreme[nu] like `:noremenu` but for Normal mode
noautocmd	:noa[utocmd] following command don't trigger autocommands
noremap	:no[remap] enter a mapping that will not be remapped
nohlsearch	:noh[lsearch] suspend 'hlsearch' highlighting
noreabbrev	:norea[bbrev] enter an abbreviation that will not be remapped
noremenu	:noreme[nu] enter a menu that will not be remapped
normal	:norm[al] execute Normal mode commands
number	:nu[mber] print lines with line number
nunmap	:nun[map] like `:unmap` but for Normal mode
nunmenu	:nunme[nu] remove menu for Normal mode
oldfiles	:ol[dfiles] list files that have marks in the viminfo file
open	:o[pen] start open mode (not implemented)
omap	:om[ap] like `:map` but for Operator-pending mode
omapclear	:omapc[lear] remove all mappings for Operator-pending mode
omenu	:ome[nu] add menu for Operator-pending mode
only	:on[ly] close all windows except the current one
onoremap	:ono[remap] like `:noremap` but for Operator-pending mode
onoremenu	:onoreme[nu] like `:noremenu` but for Operator-pending mode
options	:opt[ions] open the options-window
ounmap	:ou[nmap] like `:unmap` but for Operator-pending mode
ounmenu	:ounme[nu] remove menu for Operator-pending mode
ownsyntax	:ow[nsyntax] set new local syntax highlight for this window
pclose	:pc[lose] close preview window
pedit	:ped[it] edit file in the preview window
perl	:pe[rl] execute Perl command
print	:p[rint] print lines
profdel	:profd[el] stop profiling a function or script
profile	:prof[ile] profiling functions and scripts
promptfind	:pro[mptfind] open GUI dialog for searching
promptrepl	:promptr[epl] open GUI dialog for search/replace
perldo	:perld[o] execute Perl command for each line
pop	:po[p] jump to older entry in tag stack
popup	:pop[up] popup a menu by name
ppop	:pp[op] `:pop` in preview window
preserve	:pre[serve] write all text to swap file
previous	:prev[ious] go to previous file in argument list
psearch	:ps[earch] like `:ijump` but shows match in preview window
ptag	:pt[ag] show tag in preview window
ptNext	:ptN[ext] :tNext in preview window
ptfirst	:ptf[irst] :trewind in preview window
ptjump	:ptj[ump] :tjump and show tag in preview window
ptlast	:ptl[ast] :tlast in preview window
ptnext	:ptn[ext] :tnext in preview window
ptprevious	:ptp[revious] :tprevious in preview window
ptrewind	:ptr[ewind] :trewind in preview window
ptselect	:pts[elect] :tselect and show tag in preview window
put	:pu[t] insert contents of register in the text
pwd	:pw[d] print current directory
py3	:py3 execute Python 3 command
python3	:python3 same as :py3
py3file	:py3f[ile] execute Python 3 script file
python	:py[thon] execute Python command
pyfile	:pyf[ile] execute Python script file
quit	:q[uit] quit current window (when one window quit Vim)
quitall	:quita[ll] quit Vim
qall	:qa[ll] quit Vim
read	:r[ead] read file into the text
recover	:rec[over] recover a file from a swap file
redo	:red[o] redo one undone change
redir	:redi[r] redirect messages to a file or register
redraw	:redr[aw] force a redraw of the display
redrawstatus	:redraws[tatus] force a redraw of the status line(s)
registers	:reg[isters] display the contents of registers
resize	:res[ize] change current window height
retab	:ret[ab] change tab size
return	:retu[rn] return from a user function
rewind	:rew[ind] go to the first file in the argument list
right	:ri[ght] right align text
rightbelow	:rightb[elow] make split window appear right or below
ruby	:rub[y] execute Ruby command
rubydo	:rubyd[o] execute Ruby command for each line
rubyfile	:rubyf[ile] execute Ruby script file
rundo	:rund[o] read undo information from a file
runtime	:ru[ntime] source vim scripts in 'runtimepath'
rviminfo	:rv[iminfo] read from viminfo file
substitute	:s[ubstitute] find and replace text
sNext	:sN[ext] split window and go to previous file in argument list
sandbox	:san[dbox] execute a command in the sandbox
sargument	:sa[rgument] split window and go to specific file in argument list
sall	:sal[l] open a window for each file in argument list
saveas	:sav[eas] save file under another name.
sbuffer	:sb[uffer] split window and go to specific file in the buffer list
sbNext	:sbN[ext] split window and go to previous file in the buffer list
sball	:sba[ll] open a window for each file in the buffer list
sbfirst	:sbf[irst] split window and go to first file in the buffer list
sblast	:sbl[ast] split window and go to last file in buffer list
sbmodified	:sbm[odified] split window and go to modified file in the buffer list
sbnext	:sbn[ext] split window and go to next file in the buffer list
sbprevious	:sbp[revious] split window and go to previous file in the buffer list
sbrewind	:sbr[ewind] split window and go to first file in the buffer list
scriptnames	:scrip[tnames] list names of all sourced Vim scripts
scriptencoding	:scripte[ncoding] encoding used in sourced Vim script
scscope	:scs[cope] split window and execute cscope command
set	:se[t] show or set options
setfiletype	:setf[iletype] set 'filetype', unless it was set already
setglobal	:setg[lobal] show global values of options
setlocal	:setl[ocal] show or set options locally
sfind	:sf[ind] split current window and edit file in 'path'
sfirst	:sfir[st] split window and go to first file in the argument list
shell	:sh[ell] escape to a shell
simalt	:sim[alt] Win32 GUI: simulate Windows ALT key
sign	:sig[n] manipulate signs
silent	:sil[ent] run a command silently
sleep	:sl[eep] do nothing for a few seconds
slast	:sla[st] split window and go to last file in the argument list
smagic	:sm[agic] :substitute with 'magic'
smap	:sma[p] like `:map` but for Select mode
smapclear	:smapc[lear] remove all mappings for Select mode
smenu	:sme[nu] add menu for Select mode
snext	:sn[ext] split window and go to next file in the argument list
sniff	:sni[ff] send request to sniff
snomagic	:sno[magic] :substitute with 'nomagic'
snoremap	:snor[emap] like `:noremap` but for Select mode
snoremenu	:snoreme[nu] like `:noremenu` but for Select mode
sort	:sor[t] sort lines
source	:so[urce] read Vim or Ex commands from a file
spelldump	:spelld[ump] split window and fill with all correct words
spellgood	:spe[llgood] add good word for spelling
spellinfo	:spelli[nfo] show info about loaded spell files
spellrepall	:spellr[epall] replace all bad words like last z=
spellundo	:spellu[ndo] remove good or bad word
spellwrong	:spellw[rong] add spelling mistake
split	:sp[lit] split current window
sprevious	:spr[evious] split window and go to previous file in the argument list
srewind	:sre[wind] split window and go to first file in the argument list
stop	:st[op] suspend the editor or escape to a shell
stag	:sta[g] split window and jump to a tag
startinsert	:star[tinsert] start Insert mode
startgreplace	:startg[replace] start Virtual Replace mode
startreplace	:startr[eplace] start Replace mode
stopinsert	:stopi[nsert] stop Insert mode
stjump	:stj[ump] do `:tjump` and split window
stselect	:sts[elect] do `:tselect` and split window
sunhide	:sun[hide] same as `:unhide`
sunmap	:sunm[ap] like `:unmap` but for Select mode
sunmenu	:sunme[nu] remove menu for Select mode
suspend	:sus[pend] same as `:stop`
sview	:sv[iew] split window and edit file read-only
swapname	:sw[apname] show the name of the current swap file
syntax	:sy[ntax] syntax highlighting
syncbind	:sync[bind] sync scroll binding
t	:t same as `:copy`
tNext	:tN[ext] jump to previous matching tag
tabNext	:tabN[ext] go to previous tab page
tabclose	:tabc[lose] close current tab page
tabdo	:tabdo execute command in each tab page
tabedit	:tabe[dit] edit a file in a new tab page
tabfind	:tabf[ind] find file in 'path', edit it in a new tab page
tabfirst	:tabfir[st] got to first tab page
tablast	:tabl[ast] got to last tab page
tabmove	:tabm[ove] move tab page to other position
tabnew	:tabnew edit a file in a new tab page
tabnext	:tabn[ext] go to next tab page
tabonly	:tabo[nly] close all tab pages except the current one
tabprevious	:tabp[revious] go to previous tab page
tabrewind	:tabr[ewind] got to first tab page
tabs	:tabs list the tab pages and what they contain
tab	:tab create new tab when opening new window
tag	:ta[g] jump to tag
tags	:tags show the contents of the tag stack
tcl	:tc[l] execute Tcl command
tcldo	:tcld[o] execute Tcl command for each line
tclfile	:tclf[ile] execute Tcl script file
tearoff	:te[aroff] tear-off a menu
tfirst	:tf[irst] jump to first matching tag
throw	:th[row] throw an exception
tjump	:tj[ump] like `:tselect`, but jump directly when there is only one match
tlast	:tl[ast] jump to last matching tag
tmenu	:tm[enu] define menu tooltip
tnext	:tn[ext] jump to next matching tag
topleft	:to[pleft] make split window appear at top or far left
tprevious	:tp[revious] jump to previous matching tag
trewind	:tr[ewind] jump to first matching tag
try	:try execute commands, abort on error or exception
tselect	:ts[elect] list matching tags and select one
tunmenu	:tu[nmenu] remove menu tooltip
undo	:u[ndo] undo last change(s)
undojoin	:undoj[oin] join next change with previous undo block
undolist	:undol[ist] list leafs of the undo tree
unabbreviate	:una[bbreviate] remove abbreviation
unhide	:unh[ide] open a window for each loaded file in the buffer list
unlet	:unl[et] delete variable
unlockvar	:unlo[ckvar] unlock variables
unmap	:unm[ap] remove mapping
unmenu	:unme[nu] remove menu
unsilent	:uns[ilent] run a command not silently
update	:up[date] write buffer if modified
vglobal	:v[global] execute commands for not matching lines
version	:ve[rsion] print version number and other info
verbose	:verb[ose] execute command with 'verbose' set
vertical	:vert[ical] make following command split vertically
vimgrep	:vim[grep] search for pattern in files
vimgrepadd	:vimgrepa[dd] like :vimgrep, but append to current list
visual	:vi[sual] same as `:edit`, but turns off `Ex` mode
viusage	:viu[sage] overview of Normal mode commands
view	:vie[w] edit a file read-only
vmap	:vm[ap] like `:map` but for Visual+Select mode
vmapclear	:vmapc[lear] remove all mappings for Visual+Select mode
vmenu	:vme[nu] add menu for Visual+Select mode
vnew	:vne[w] create a new empty window, vertically split
vnoremap	:vn[oremap] like `:noremap` but for Visual+Select mode
vnoremenu	:vnoreme[nu] like `:noremenu` but for Visual+Select mode
vsplit	:vs[plit] split current window vertically
vunmap	:vu[nmap] like `:unmap` but for Visual+Select mode
vunmenu	:vunme[nu] remove menu for Visual+Select mode
windo	:windo execute command in each window
write	:w[rite] write to a file
wNext	:wN[ext] write to a file and go to previous file in argument list
wall	:wa[ll] write all (changed) buffers
while	:wh[ile] execute loop for as long as condition met
winsize	:wi[nsize] get or set window size (obsolete)
wincmd	:winc[md] execute a Window (CTRL-W) command
winpos	:winp[os] get or set window position
wnext	:wn[ext] write to a file and go to next file in argument list
wprevious	:wp[revious] write to a file and go to previous file in argument list
wq	:wq write to a file and quit window or Vim
wqall	:wqa[ll] write all changed buffers and quit Vim
wsverb	:ws[verb] pass the verb to workshop over IPC
wundo	:wu[ndo] write undo information to a file
wviminfo	:wv[iminfo] write to viminfo file
xit	:x[it] write if buffer changed and quit window or Vim
xall	:xa[ll] same as `:wqall`
xmapclear	:xmapc[lear] remove all mappings for Visual mode
xmap	:xm[ap] like `:map` but for Visual mode
xmenu	:xme[nu] add menu for Visual mode
xnoremap	:xn[oremap] like `:noremap` but for Visual mode
xnoremenu	:xnoreme[nu] like `:noremenu` but for Visual mode
xunmap	:xu[nmap] like `:unmap` but for Visual mode
xunmenu	:xunme[nu] remove menu for Visual mode
yank	:y[ank] yank lines into a register
z	:z print some lines
~	:~ repeat last `:substitute`
