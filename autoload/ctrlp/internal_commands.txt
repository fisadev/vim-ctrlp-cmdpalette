  !	              :!                     filter lines or execute an external command
  !!	              :!!                    repeat last `:!` command
  #	              :#                     same as `:number`
  &	              :&                     repeat last `:substitute`
  star	          :*                     execute contents of a register
  <	              :<                     shift lines one 'shiftwidth' left
  =	              :=                     print the cursor line number
  >	              :>                     shift lines one 'shiftwidth' right
  @	              :@                     execute contents of a register
  @@	              :@@                    repeat the previous `:@`
  Next	          :N[ext]                go to previous file in the argument list
  Print	          :P[rint]               print lines
  X	              :X                     ask for encryption key
  append	          :a[ppend]              append text
  abbreviate	      :ab[breviate]          enter abbreviation
  abclear	          :abc[lear]             remove all abbreviations
  aboveleft	      :abo[veleft]           make split window appear left or above
  all	              :al[l]                 open a window for each file in the argument list
  amenu	          :am[enu]               enter new menu item for all modes
  anoremenu	      :an[oremenu]           enter a new menu for all modes that will not be remapped
  args	          :ar[gs]                print the argument list
  argadd	          :arga[dd]              add items to the argument list
  argdelete	      :argd[elete]           delete items from the argument list
  argedit	          :arge[dit]             add item to the argument list and edit it
  argdo	          :argdo                 do a command on all items in the argument list
  argglobal	      :argg[lobal]           define the global argument list
  arglocal	      :argl[ocal]            define a local argument list
  argument	      :argu[ment]            go to specific file in the argument list
  ascii	          :as[cii]               print ascii value of character under the cursor
  autocmd	          :au[tocmd]             enter or show autocommands
  augroup	          :aug[roup]             select the autocommand group to use
  aunmenu	          :aun[menu]             remove menu for all modes
  buffer	          :b[uffer]              go to specific buffer in the buffer list
  bNext	          :bN[ext]               go to previous buffer in the buffer list
  ball	          :ba[ll]                open a window for each buffer in the buffer list
  badd	          :bad[d]                add buffer to the buffer list
  bdelete	          :bd[elete]             remove a buffer from the buffer list
  behave	          :be[have]              set mouse and selection behavior
  belowright	      :bel[owright]          make split window appear right or below
  bfirst	          :bf[irst]              go to first buffer in the buffer list
  blast	          :bl[ast]               go to last buffer in the buffer list
  bmodified	      :bm[odified]           go to next buffer in the buffer list that has been modified
  bnext	          :bn[ext]               go to next buffer in the buffer list
  botright	      :bo[tright]            make split window appear at bottom or far right
  bprevious	      :bp[revious]           go to previous buffer in the buffer list
  brewind	          :br[ewind]             go to first buffer in the buffer list
  break	          :brea[k]               break out of while loop
  breakadd	      :breaka[dd]            add a debugger breakpoint
  breakdel	      :breakd[el]            delete a debugger breakpoint
  breaklist	      :breakl[ist]           list debugger breakpoints
  browse	          :bro[wse]              use file selection dialog
  bufdo	          :bufdo                 execute command in each listed buffer
  buffers	          :buffers               list all files in the buffer list
  bunload	          :bun[load]             unload a specific buffer
  bwipeout	      :bw[ipeout]            really delete a buffer
  change	          :c[hange]              replace a line or series of lines
  cNext	          :cN[ext]               go to previous error
  cNfile	          :cNf[ile]              go to last error in previous file
  cabbrev	          :ca[bbrev]             like `:abbreviate` but for Command-line mode
  cabclear	      :cabc[lear]            clear all abbreviations for Command-line mode
  caddbuffer	      :caddb[uffer]          add errors from buffer
  caddexpr	      :cad[dexpr]            add errors from expr
  caddfile	      :caddf[ile]            add error message to current quickfix list
  call	          :cal[l]                call a function
  catch	          :cat[ch]               part of a :try command
  cbuffer	          :cb[uffer]             parse error messages and jump to first error
  cc	              :cc                    go to specific error
  cclose	          :ccl[ose]              close quickfix window
  cd	              :cd                    change directory
  center	          :ce[nter]              format lines at the center
  cexpr	          :cex[pr]               read errors from expr and jump to first
  cfile	          :cf[ile]               read file with error messages and jump to first
  cfirst	          :cfir[st]              go to the specified error, default first one
  cgetbuffer	      :cgetb[uffer]          get errors from buffer
  cgetexpr	      :cgete[xpr]            get errors from expr
  cgetfile	      :cg[etfile]            read file with error messages
  changes	          :cha[nges]             print the change list
  chdir	          :chd[ir]               change directory
  checkpath	      :che[ckpath]           list included files
  checktime	      :checkt[ime]           check timestamp of loaded buffers
  clist	          :cl[ist]               list all errors
  clast	          :cla[st]               go to the specified error, default last one
  close	          :clo[se]               close current window
  cmap	          :cm[ap]                like `:map` but for Command-line mode
  cmapclear	      :cmapc[lear]           clear all mappings for Command-line mode
  cmenu	          :cme[nu]               add menu for Command-line mode
  cnext	          :cn[ext]               go to next error
  cnewer	          :cnew[er]              go to newer error list
  cnfile	          :cnf[ile]              go to first error in next file
  cnoremap	      :cno[remap]            like `:noremap` but for Command-line mode
  cnoreabbrev	      :cnorea[bbrev]         like `:noreabbrev` but for Command-line mode
  cnoremenu	      :cnoreme[nu]           like `:noremenu` but for Command-line mode
  copy	          :co[py]                copy lines
  colder	          :col[der]              go to older error list
  colorscheme	      :colo[rscheme]         load a specific color scheme
  command	          :com[mand]             create user-defined command
  comclear	      :comc[lear]            clear all user-defined commands
  compiler	      :comp[iler]            do settings for a specific compiler
  continue	      :con[tinue]            go back to :while
  confirm	          :conf[irm]             prompt user when confirmation required
  copen	          :cope[n]               open quickfix window
  cprevious	      :cp[revious]           go to previous error
  cpfile	          :cpf[ile]              go to last error in previous file
  cquit	          :cq[uit]               quit Vim with an error code
  crewind	          :cr[ewind]             go to the specified error, default first one
  cscope	          :cs[cope]              execute cscope command
  cstag	          :cst[ag]               use cscope to jump to a tag
  cunmap	          :cu[nmap]              like `:unmap` but for Command-line mode
  cunabbrev	      :cuna[bbrev]           like `:unabbrev` but for Command-line mode
  cunmenu	          :cunme[nu]             remove menu for Command-line mode
  cwindow	          :cw[indow]             open or close quickfix window
  delete	          :d[elete]              delete lines
  delmarks	      :delm[arks]            delete marks
  debug	          :deb[ug]               run a command in debugging mode
  debuggreedy	      :debugg[reedy]         read debug mode commands from normal input
  delcommand	      :delc[ommand]          delete user-defined command
  delfunction	      :delf[unction]         delete a user function
  diffupdate	      :dif[fupdate]          update 'diff' buffers
  diffget	          :diffg[et]             remove differences in current buffer
  diffoff	          :diffo[ff]             switch off diff mode
  diffpatch	      :diffp[atch]           apply a patch and show differences
  diffput	          :diffpu[t]             remove differences in other buffer
  diffsplit	      :diffs[plit]           show differences with another file
  diffthis	      :diffthis              make current window a diff window
  digraphs	      :dig[raphs]            show or enter digraphs
  display	          :di[splay]             display registers
  djump	          :dj[ump]               jump to #define
  dlist	          :dl[ist]               list #defines
  doautocmd	      :do[autocmd]           apply autocommands to current buffer
  doautoall	      :doautoa[ll]           apply autocommands for all loaded buffers
  drop	          :dr[op]                jump to window editing file or edit file in current window
  dsearch	          :ds[earch]             list one #define
  dsplit	          :dsp[lit]              split window and jump to #define
  edit	          :e[dit]                edit a file
  earlier	          :ea[rlier]             go to older change, undo
  echo	          :ec[ho]                echoes the result of expressions
  echoerr	          :echoe[rr]             like :echo, show like an error and use history
  echohl	          :echoh[l]              set highlighting for echo commands
  echomsg	          :echom[sg]             same as :echo, put message in history
  echon	          :echon                 same as :echo, but without <EOL>
  else	          :el[se]                part of an :if command
  elseif	          :elsei[f]              part of an :if command
  emenu	          :em[enu]               execute a menu by name
  endif	          :en[dif]               end previous :if
  endfor	          :endfo[r]              end previous :for
  endfunction	      :endf[unction]         end of a user function
  endtry	          :endt[ry]              end previous :try
  endwhile	      :endw[hile]            end previous :while
  enew	          :ene[w]                edit a new, unnamed buffer
  ex	              :ex                    same as `:edit`
  execute	          :exe[cute]             execute result of expressions
  exit	          :exi[t]                same as `:xit`
  exusage	          :exu[sage]             overview of Ex commands
  file	          :f[ile]                show or set the current file name
  files	          :files                 list all files in the buffer list
  filetype	      :filet[ype]            switch file type detection on/off
  find	          :fin[d]                find file in 'path' and edit it
  finally	          :fina[lly]             part of a :try command
  finish	          :fini[sh]              quit sourcing a Vim script
  first	          :fir[st]               go to the first file in the argument list
  fixdel	          :fix[del]              set key code of <Del>
  fold	          :fo[ld]                create a fold
  foldclose	      :foldc[lose]           close folds
  folddoopen	      :foldd[oopen]          execute command on lines not in a closed fold
  folddoclosed	  :folddoc[losed]        execute command on lines in a closed fold
  foldopen	      :foldo[pen]            open folds
  for	              :for                   for loop
  function	      :fu[nction]            define a user function
  global	          :g[lobal]              execute commands for matching lines
  goto	          :go[to]                go to byte in the buffer
  grep	          :gr[ep]                run 'grepprg' and jump to first match
  grepadd	          :grepa[dd]             like :grep, but append to current list
  gui	              :gu[i]                 start the GUI
  gvim	          :gv[im]                start the GUI
  hardcopy	      :ha[rdcopy]            send text to the printer
  help	          :h[elp]                open a help window
  helpfind	      :helpf[ind]            dialog to open a help window
  helpgrep	      :helpg[rep]            like `:grep` but searches help files
  helptags	      :helpt[ags]            generate help tags for a directory
  highlight	      :hi[ghlight]           specify highlighting methods
  hide	          :hid[e]                hide current buffer for a command
  history	          :his[tory]             print a history list
  insert	          :i[nsert]              insert text
  iabbrev	          :ia[bbrev]             like `:abbrev` but for Insert mode
  iabclear	      :iabc[lear]            like `:abclear` but for Insert mode
  if	              :if                    execute commands when condition met
  ijump	          :ij[ump]               jump to definition of identifier
  ilist	          :il[ist]               list lines where identifier matches
  imap	          :im[ap]                like `:map` but for Insert mode
  imapclear	      :imapc[lear]           like `:mapclear` but for Insert mode
  imenu	          :ime[nu]               add menu for Insert mode
  inoremap	      :ino[remap]            like `:noremap` but for Insert mode
  inoreabbrev	      :inorea[bbrev]         like `:noreabbrev` but for Insert mode
  inoremenu	      :inoreme[nu]           like `:noremenu` but for Insert mode
  intro	          :int[ro]               print the introductory message
  isearch	          :is[earch]             list one line where identifier matches
  isplit	          :isp[lit]              split window and jump to definition of identifier
  iunmap	          :iu[nmap]              like `:unmap` but for Insert mode
  iunabbrev	      :iuna[bbrev]           like `:unabbrev` but for Insert mode
  iunmenu	          :iunme[nu]             remove menu for Insert mode
  join	          :j[oin]                join lines
  jumps	          :ju[mps]               print the jump list
  k	              :k                     set a mark
  keepalt	          :keepa[lt]             following command keeps the alternate file
  keepmarks	      :kee[pmarks]           following command keeps marks where they are
  keepjumps	      :keepj[umps]           following command keeps jumplist and marks
  lNext	          :lN[ext]               go to previous entry in location list
  lNfile	          :lNf[ile]              go to last entry in previous file
  list	          :l[ist]                print lines
  laddexpr	      :lad[dexpr]            add locations from expr
  laddbuffer	      :laddb[uffer]          add locations from buffer
  laddfile	      :laddf[ile]            add locations to current location list
  last	          :la[st]                go to the last file in the argument list
  language	      :lan[guage]            set the language (locale)
  later	          :lat[er]               go to newer change, redo
  lbuffer	          :lb[uffer]             parse locations and jump to first location
  lcd	              :lc[d]                 change directory locally
  lchdir	          :lch[dir]              change directory locally
  lclose	          :lcl[ose]              close location window
  lcscope	          :lcs[cope]             like `:cscope` but uses location list
  left	          :le[ft]                left align lines
  leftabove	      :lefta[bove]           make split window appear left or above
  let	              :let                   assign a value to a variable or option
  lexpr	          :lex[pr]               read locations from expr and jump to first
  lfile	          :lf[ile]               read file with locations and jump to first
  lfirst	          :lfir[st]              go to the specified location, default first one
  lgetbuffer	      :lgetb[uffer]          get locations from buffer
  lgetexpr	      :lgete[xpr]            get locations from expr
  lgetfile	      :lg[etfile]            read file with locations
  lgrep	          :lgr[ep]               run 'grepprg' and jump to first match
  lgrepadd	      :lgrepa[dd]            like :grep, but append to current list
  lhelpgrep	      :lh[elpgrep]           like `:helpgrep` but uses location list
  ll	              :ll                    go to specific location
  llast	          :lla[st]               go to the specified location, default last one
  llist	          :lli[st]               list all locations
  lmake	          :lmak[e]               execute external command 'makeprg' and parse error messages
  lmap	          :lm[ap]                like `:map!` but includes Lang-Arg mode
  lmapclear	      :lmapc[lear]           like `:mapclear!` but includes Lang-Arg mode
  lnext	          :lne[xt]               go to next location
  lnewer	          :lnew[er]              go to newer location list
  lnfile	          :lnf[ile]              go to first location in next file
  lnoremap	      :ln[oremap]            like `:noremap!` but includes Lang-Arg mode
  loadkeymap	      :loadk[eymap]          load the following keymaps until EOF
  loadview	      :lo[adview]            load view for current window from a file
  lockmarks	      :loc[kmarks]           following command keeps marks where they are
  lockvar	          :lockv[ar]             lock variables
  lolder	          :lol[der]              go to older location list
  lopen	          :lope[n]               open location window
  lprevious	      :lp[revious]           go to previous location
  lpfile	          :lpf[ile]              go to last location in previous file
  lrewind	          :lr[ewind]             go to the specified location, default first one
  ls	              :ls                    list all buffers
  ltag	          :lt[ag]                jump to tag and add matching tags to the location list
  lunmap	          :lu[nmap]              like `:unmap!` but includes Lang-Arg mode
  lua	              :lua                   execute Lua command
  luado	          :luad[o]               execute Lua command for each line
  luafile	          :luaf[ile]             execute Lua script file
  lvimgrep	      :lv[imgrep]            search for pattern in files
  lvimgrepadd	      :lvimgrepa[dd]         like :vimgrep, but append to current list
  lwindow	          :lw[indow]             open or close location window
  move	          :m[ove]                move lines
  mark	          :ma[rk]                set a mark
  make	          :mak[e]                execute external command 'makeprg' and parse error messages
  map	              :map                   show or enter a mapping
  mapclear	      :mapc[lear]            clear all mappings for Normal and Visual mode
  marks	          :marks                 list all marks
  match	          :mat[ch]               define a match to highlight
  menu	          :me[nu]                enter a new menu item
  menutranslate	  :menut[ranslate]       add a menu translation item
  messages	      :mes[sages]            view previously displayed messages
  mkexrc	          :mk[exrc]              write current mappings and settings to a file
  mksession	      :mks[ession]           write session info to a file
  mkspell	          :mksp[ell]             produce .spl spell file
  mkvimrc	          :mkv[imrc]             write current mappings and settings to a file
  mkview	          :mkvie[w]              write view of current window to a file
  mode	          :mod[e]                show or change the screen mode
  mzscheme	      :mz[scheme]            execute MzScheme command
  mzfile	          :mzf[ile]              execute MzScheme script file
  nbclose	          :nbc[lose]             close the current Netbeans session
  nbkey	          :nb[key]               pass a key to Netbeans
  nbstart	          :nbs[art]              start a new Netbeans session
  next	          :n[ext]                go to next file in the argument list
  new	              :new                   create a new empty window
  nmap	          :nm[ap]                like `:map` but for Normal mode
  nmapclear	      :nmapc[lear]           clear all mappings for Normal mode
  nmenu	          :nme[nu]               add menu for Normal mode
  nnoremap	      :nn[oremap]            like `:noremap` but for Normal mode
  nnoremenu	      :nnoreme[nu]           like `:noremenu` but for Normal mode
  noautocmd	      :noa[utocmd]           following command don't trigger autocommands
  noremap	          :no[remap]             enter a mapping that will not be remapped
  nohlsearch	      :noh[lsearch]          suspend 'hlsearch' highlighting
  noreabbrev	      :norea[bbrev]          enter an abbreviation that will not be remapped
  noremenu	      :noreme[nu]            enter a menu that will not be remapped
  normal	          :norm[al]              execute Normal mode commands
  number	          :nu[mber]              print lines with line number
  nunmap	          :nun[map]              like `:unmap` but for Normal mode
  nunmenu	          :nunme[nu]             remove menu for Normal mode
  oldfiles	      :ol[dfiles]            list files that have marks in the viminfo file
  open	          :o[pen]                start open mode (not implemented)
  omap	          :om[ap]                like `:map` but for Operator-pending mode
  omapclear	      :omapc[lear]           remove all mappings for Operator-pending mode
  omenu	          :ome[nu]               add menu for Operator-pending mode
  only	          :on[ly]                close all windows except the current one
  onoremap	      :ono[remap]            like `:noremap` but for Operator-pending mode
  onoremenu	      :onoreme[nu]           like `:noremenu` but for Operator-pending mode
  options	          :opt[ions]             open the options-window
  ounmap	          :ou[nmap]              like `:unmap` but for Operator-pending mode
  ounmenu	          :ounme[nu]             remove menu for Operator-pending mode
  ownsyntax	      :ow[nsyntax]           set new local syntax highlight for this window
  pclose	          :pc[lose]              close preview window
  pedit	          :ped[it]               edit file in the preview window
  perl	          :pe[rl]                execute Perl command
  print	          :p[rint]               print lines
  profdel	          :profd[el]             stop profiling a function or script
  profile	          :prof[ile]             profiling functions and scripts
  promptfind	      :pro[mptfind]          open GUI dialog for searching
  promptrepl	      :promptr[epl]          open GUI dialog for search/replace
  perldo	          :perld[o]              execute Perl command for each line
  pop	              :po[p]                 jump to older entry in tag stack
  popup	          :pop[up]               popup a menu by name
  ppop	          :pp[op]                `:pop` in preview window
  preserve	      :pre[serve]            write all text to swap file
  previous	      :prev[ious]            go to previous file in argument list
  psearch	          :ps[earch]             like `:ijump` but shows match in preview window
  ptag	          :pt[ag]                show tag in preview window
  ptNext	          :ptN[ext]              :tNext in preview window
  ptfirst	          :ptf[irst]             :trewind in preview window
  ptjump	          :ptj[ump]              :tjump and show tag in preview window
  ptlast	          :ptl[ast]              :tlast in preview window
  ptnext	          :ptn[ext]              :tnext in preview window
  ptprevious	      :ptp[revious]          :tprevious in preview window
  ptrewind	      :ptr[ewind]            :trewind in preview window
  ptselect	      :pts[elect]            :tselect and show tag in preview window
  put	              :pu[t]                 insert contents of register in the text
  pwd	              :pw[d]                 print current directory
  py3	              :py3                   execute Python 3 command
  python3	          :python3               same as :py3
  py3file	          :py3f[ile]             execute Python 3 script file
  python	          :py[thon]              execute Python command
  pyfile	          :pyf[ile]              execute Python script file
  quit	          :q[uit]                quit current window (when one window quit Vim)
  quitall	          :quita[ll]             quit Vim
  qall	          :qa[ll]                quit Vim
  read	          :r[ead]                read file into the text
  recover	          :rec[over]             recover a file from a swap file
  redo	          :red[o]                redo one undone change
  redir	          :redi[r]               redirect messages to a file or register
  redraw	          :redr[aw]              force a redraw of the display
  redrawstatus	  :redraws[tatus]        force a redraw of the status line(s)
  registers	      :reg[isters]           display the contents of registers
  resize	          :res[ize]              change current window height
  retab	          :ret[ab]               change tab size
  return	          :retu[rn]              return from a user function
  rewind	          :rew[ind]              go to the first file in the argument list
  right	          :ri[ght]               right align text
  rightbelow	      :rightb[elow]          make split window appear right or below
  ruby	          :rub[y]                execute Ruby command
  rubydo	          :rubyd[o]              execute Ruby command for each line
  rubyfile	      :rubyf[ile]            execute Ruby script file
  rundo	          :rund[o]               read undo information from a file
  runtime	          :ru[ntime]             source vim scripts in 'runtimepath'
  rviminfo	      :rv[iminfo]            read from viminfo file
  substitute	      :s[ubstitute]          find and replace text
  sNext	          :sN[ext]               split window and go to previous file in argument list
  sandbox	          :san[dbox]             execute a command in the sandbox
  sargument	      :sa[rgument]           split window and go to specific file in argument list
  sall	          :sal[l]                open a window for each file in argument list
  saveas	          :sav[eas]              save file under another name.
  sbuffer	          :sb[uffer]             split window and go to specific file in the buffer list
  sbNext	          :sbN[ext]              split window and go to previous file in the buffer list
  sball	          :sba[ll]               open a window for each file in the buffer list
  sbfirst	          :sbf[irst]             split window and go to first file in the buffer list
  sblast	          :sbl[ast]              split window and go to last file in buffer list
  sbmodified	      :sbm[odified]          split window and go to modified file in the buffer list
  sbnext	          :sbn[ext]              split window and go to next file in the buffer list
  sbprevious	      :sbp[revious]          split window and go to previous file in the buffer list
  sbrewind	      :sbr[ewind]            split window and go to first file in the buffer list
  scriptnames	      :scrip[tnames]         list names of all sourced Vim scripts
  scriptencoding	  :scripte[ncoding]  encoding used in sourced Vim script
  scscope	          :scs[cope]             split window and execute cscope command
  set	              :se[t]                 show or set options
  setfiletype	      :setf[iletype]         set 'filetype', unless it was set already
  setglobal	      :setg[lobal]           show global values of options
  setlocal	      :setl[ocal]            show or set options locally
  sfind	          :sf[ind]               split current window and edit file in 'path'
  sfirst	          :sfir[st]              split window and go to first file in the argument list
  shell	          :sh[ell]               escape to a shell
  simalt	          :sim[alt]              Win32 GUI: simulate Windows ALT key
  sign	          :sig[n]                manipulate signs
  silent	          :sil[ent]              run a command silently
  sleep	          :sl[eep]               do nothing for a few seconds
  slast	          :sla[st]               split window and go to last file in the argument list
  smagic	          :sm[agic]              :substitute with 'magic'
  smap	          :sma[p]                like `:map` but for Select mode
  smapclear	      :smapc[lear]           remove all mappings for Select mode
  smenu	          :sme[nu]               add menu for Select mode
  snext	          :sn[ext]               split window and go to next file in the argument list
  sniff	          :sni[ff]               send request to sniff
  snomagic	      :sno[magic]            :substitute with 'nomagic'
  snoremap	      :snor[emap]            like `:noremap` but for Select mode
  snoremenu	      :snoreme[nu]           like `:noremenu` but for Select mode
  sort	          :sor[t]                sort lines
  source	          :so[urce]              read Vim or Ex commands from a file
  spelldump	      :spelld[ump]           split window and fill with all correct words
  spellgood	      :spe[llgood]           add good word for spelling
  spellinfo	      :spelli[nfo]           show info about loaded spell files
  spellrepall	      :spellr[epall]         replace all bad words like last z=
  spellundo	      :spellu[ndo]           remove good or bad word
  spellwrong	      :spellw[rong]          add spelling mistake
  split	          :sp[lit]               split current window
  sprevious	      :spr[evious]           split window and go to previous file in the argument list
  srewind	          :sre[wind]             split window and go to first file in the argument list
  stop	          :st[op]                suspend the editor or escape to a shell
  stag	          :sta[g]                split window and jump to a tag
  startinsert	      :star[tinsert]         start Insert mode
  startgreplace	  :startg[replace]       start Virtual Replace mode
  startreplace	  :startr[eplace]        start Replace mode
  stopinsert	      :stopi[nsert]          stop Insert mode
  stjump	          :stj[ump]              do `:tjump` and split window
  stselect	      :sts[elect]            do `:tselect` and split window
  sunhide	          :sun[hide]             same as `:unhide`
  sunmap	          :sunm[ap]              like `:unmap` but for Select mode
  sunmenu	          :sunme[nu]             remove menu for Select mode
  suspend	          :sus[pend]             same as `:stop`
  sview	          :sv[iew]               split window and edit file read-only
  swapname	      :sw[apname]            show the name of the current swap file
  syntax	          :sy[ntax]              syntax highlighting
  syncbind	      :sync[bind]            sync scroll binding
  t	              :t                     same as `:copy`
  tNext	          :tN[ext]               jump to previous matching tag
  tabNext	          :tabN[ext]             go to previous tab page
  tabclose	      :tabc[lose]            close current tab page
  tabdo	          :tabdo                 execute command in each tab page
  tabedit	          :tabe[dit]             edit a file in a new tab page
  tabfind	          :tabf[ind]             find file in 'path', edit it in a new tab page
  tabfirst	      :tabfir[st]            got to first tab page
  tablast	          :tabl[ast]             got to last tab page
  tabmove	          :tabm[ove]             move tab page to other position
  tabnew	          :tabnew                edit a file in a new tab page
  tabnext	          :tabn[ext]             go to next tab page
  tabonly	          :tabo[nly]             close all tab pages except the current one
  tabprevious	      :tabp[revious]         go to previous tab page
  tabrewind	      :tabr[ewind]           got to first tab page
  tabs	          :tabs                  list the tab pages and what they contain
  tab	              :tab                   create new tab when opening new window
  tag	              :ta[g]                 jump to tag
  tags	          :tags                  show the contents of the tag stack
  tcl	              :tc[l]                 execute Tcl command
  tcldo	          :tcld[o]               execute Tcl command for each line
  tclfile	          :tclf[ile]             execute Tcl script file
  tearoff	          :te[aroff]             tear-off a menu
  tfirst	          :tf[irst]              jump to first matching tag
  throw	          :th[row]               throw an exception
  tjump	          :tj[ump]               like `:tselect`, but jump directly when there is only one match
  tlast	          :tl[ast]               jump to last matching tag
  tmenu	          :tm[enu]               define menu tooltip
  tnext	          :tn[ext]               jump to next matching tag
  topleft	          :to[pleft]             make split window appear at top or far left
  tprevious	      :tp[revious]           jump to previous matching tag
  trewind	          :tr[ewind]             jump to first matching tag
  try	              :try                   execute commands, abort on error or exception
  tselect	          :ts[elect]             list matching tags and select one
  tunmenu	          :tu[nmenu]             remove menu tooltip
  undo	          :u[ndo]                undo last change(s)
  undojoin	      :undoj[oin]            join next change with previous undo block
  undolist	      :undol[ist]            list leafs of the undo tree
  unabbreviate	  :una[bbreviate]            remove abbreviation
  unhide	          :unh[ide]              open a window for each loaded file in the buffer list
  unlet	          :unl[et]               delete variable
  unlockvar	      :unlo[ckvar]           unlock variables
  unmap	          :unm[ap]               remove mapping
  unmenu	          :unme[nu]              remove menu
  unsilent	      :uns[ilent]            run a command not silently
  update	          :up[date]              write buffer if modified
  vglobal	          :v[global]             execute commands for not matching lines
  version	          :ve[rsion]             print version number and other info
  verbose	          :verb[ose]             execute command with 'verbose' set
  vertical	      :vert[ical]            make following command split vertically
  vimgrep	          :vim[grep]             search for pattern in files
  vimgrepadd	      :vimgrepa[dd]          like :vimgrep, but append to current list
  visual	          :vi[sual]              same as `:edit`, but turns off `Ex` mode
  viusage	          :viu[sage]             overview of Normal mode commands
  view	          :vie[w]                edit a file read-only
  vmap	          :vm[ap]                like `:map` but for Visual+Select mode
  vmapclear	      :vmapc[lear]           remove all mappings for Visual+Select mode
  vmenu	          :vme[nu]               add menu for Visual+Select mode
  vnew	          :vne[w]                create a new empty window, vertically split
  vnoremap	      :vn[oremap]            like `:noremap` but for Visual+Select mode
  vnoremenu	      :vnoreme[nu]           like `:noremenu` but for Visual+Select mode
  vsplit	          :vs[plit]              split current window vertically
  vunmap	          :vu[nmap]              like `:unmap` but for Visual+Select mode
  vunmenu	          :vunme[nu]             remove menu for Visual+Select mode
  windo	          :windo                 execute command in each window
  write	          :w[rite]               write to a file
  wNext	          :wN[ext]               write to a file and go to previous file in argument list
  wall	          :wa[ll]                write all (changed) buffers
  while	          :wh[ile]               execute loop for as long as condition met
  winsize	          :wi[nsize]             get or set window size (obsolete)
  wincmd	          :winc[md]              execute a Window (CTRL-W) command
  winpos	          :winp[os]              get or set window position
  wnext	          :wn[ext]               write to a file and go to next file in argument list
  wprevious	      :wp[revious]           write to a file and go to previous file in argument list
  wq	              :wq                    write to a file and quit window or Vim
  wqall	          :wqa[ll]               write all changed buffers and quit Vim
  wsverb	          :ws[verb]              pass the verb to workshop over IPC
  wundo	          :wu[ndo]               write undo information to a file
  wviminfo	      :wv[iminfo]            write to viminfo file
  xit	              :x[it]                 write if buffer changed and quit window or Vim
  xall	          :xa[ll]                same as `:wqall`
  xmapclear	      :xmapc[lear]           remove all mappings for Visual mode
  xmap	          :xm[ap]                like `:map` but for Visual mode
  xmenu	          :xme[nu]               add menu for Visual mode
  xnoremap	      :xn[oremap]            like `:noremap` but for Visual mode
  xnoremenu	      :xnoreme[nu]           like `:noremenu` but for Visual mode
  xunmap	          :xu[nmap]              like `:unmap` but for Visual mode
  xunmenu	          :xunme[nu]             remove menu for Visual mode
  yank	          :y[ank]                yank lines into a register
  z	              :z                     print some lines
  ~	              :~                     repeat last `:substitute`
